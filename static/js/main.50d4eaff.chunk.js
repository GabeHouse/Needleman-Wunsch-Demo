(this["webpackJsonpalign-react"]=this["webpackJsonpalign-react"]||[]).push([[0],{10:function(e,t,a){"use strict";a.r(t);var l=a(0),n=a.n(l),r=a(2),s=a.n(r),c=(a(9),a(3));var m=function(e){return n.a.createElement("div",{className:e.className,id:e.id,onClick:e.handleClick},n.a.createElement(c.a.div,null,e.value))};function i(e,t){!function(e){for(var t=0;t<e.length;t++)for(var a=0;a<e[0].length;a++)document.getElementById(e[t][a].id).style.backgroundColor="rgb(221, 255, 204)"}(t);for(var a=0;a<e.length;a++)document.getElementById(e[a]).style.backgroundColor="red"}function h(e){return Object(l.useEffect)((function(){i(e.D[e.D.length-1][e.D[0].length-1].path,e.D)}),[e]),n.a.createElement("div",null,n.a.createElement("table",null,n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null,n.a.createElement(m,{className:"letter_square"})),n.a.createElement("td",null,n.a.createElement(m,{className:"letter_square"})),e.seq2.split("").map((function(e,t){return n.a.createElement("td",{key:t},n.a.createElement(m,{value:e,className:"letter_square"}))}))),e.D.map((function(t,a){return n.a.createElement("tr",{key:a},n.a.createElement("td",null,n.a.createElement(m,{value:e.seq1.charAt(a-1),className:"letter_square"})),t.map((function(t,l){return n.a.createElement("td",{key:e.D[a][l].id},n.a.createElement("div",null,n.a.createElement(m,{value:e.D[a][l].score,className:"score_square",id:e.D[a][l].id,handleClick:function(){return i(e.D[a][l].path,e.D)}})))})))})))))}class o extends n.a.Component{constructor(e){super(e);this.state={seq1:"AATCTAG",seq2:"ATCGGTAG",matchScore:1,mismatchScore:-1,gapScore:-1},this.handleChange=this.handleChange.bind(this)}handleChange(e){"seq1"===e.target.id?this.setState({seq1:e.target.value.toString().toUpperCase()}):"seq2"===e.target.id?this.setState({seq2:e.target.value.toString().toUpperCase()}):"match"===e.target.id?this.setState({matchScore:e.target.value}):"mismatch"===e.target.id?this.setState({mismatchScore:e.target.value}):"gap"!==e.target.id||isNaN(e.target.value)||this.setState({gapScore:e.target.value})}render(){let e=isNaN(parseInt(this.state.matchScore))?0:parseInt(this.state.matchScore),t=isNaN(parseInt(this.state.mismatchScore))?0:parseInt(this.state.mismatchScore),a=isNaN(parseInt(this.state.gapScore))?0:parseInt(this.state.gapScore),l=function(e,t,a,l,n){let r=new Array(e.length+1);for(let s=0;s<e.length+1;s++)r[s]=new Array(t.length+1),r[s][0]={score:n*s,a:e.substring(0,s),b:"-".repeat(s)},r[s][0].id=s+",0",r[s][0].path=s>0?[...r[s-1][0].path]:[],r[s][0].path.push(r[s][0].id.valueOf());for(let s=0;s<t.length+1;s++)r[0][s]={score:n*s,a:"-".repeat(s),b:t.substring(0,s)},r[0][s].id="0,"+s.toString(),r[0][s].path=s>0?[...r[0][s-1].path]:[],r[0][s].path.push(r[0][s].id.valueOf());for(let s=0;s<e.length;s++)for(let c=0;c<t.length;c++){let m=t.charAt(c)===e.charAt(s)?a:l,i=Math.max(r[s][c].score+m,r[s][c+1].score+n,r[s+1][c].score+n);r[s+1][c+1]={},r[s+1][c+1].score=i,r[s+1][c+1].id=s+1+","+(c+1),i===r[s][c].score+m?(r[s+1][c+1].a=r[s][c].a+e.charAt(s),r[s+1][c+1].b=r[s][c].b+t.charAt(c),r[s+1][c+1].path=[...r[s][c].path]):i===r[s][c+1].score+n?(r[s+1][c+1].a=r[s][c+1].a+e.charAt(s),r[s+1][c+1].b=r[s][c+1].b+"-",r[s+1][c+1].path=[...r[s][c+1].path]):(r[s+1][c+1].a=r[s+1][c].a+"-",r[s+1][c+1].b=r[s+1][c].b+t.charAt(c),r[s+1][c+1].path=[...r[s+1][c].path]),r[s+1][c+1].path.push(r[s+1][c+1].id.valueOf())}return r}(this.state.seq1,this.state.seq2,e,t,a);return n.a.createElement("div",{id:"main"},n.a.createElement("p",null,"The ",n.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm"},"Needleman-Wunsch algorithm ")," determines the optimal alignment and match score of two strings. It reduces to popular dynamic programming problems such as ",n.a.createElement("button",{onClick:()=>{this.setState({matchScore:1,mismatchScore:0,gapScore:0})}},"Longest Common Subsequence"),"  and ",n.a.createElement("button",{onClick:()=>{this.setState({matchScore:0,mismatchScore:-1,gapScore:-1})}},"Edit Distance")," by altering the score scheme. The Needleman-Wunsch algorithm has quadratic time and linear space complexities making it useful for aligning extremely long strings like genome sequences to see if they share a common ancestor."),n.a.createElement("p",null,"The problem is solved by filling table DP using the recurrence relation,",n.a.createElement("br",null),"$$\\small","\\texttt{ DP[i, j] = max}","\\begin","{cases}","\\small","\\texttt{DP[i-1, j-1] + score(S[i], T[j])}","\\\\ \\small","\\texttt{DP[i-1, j] + score(S[i], -)}","\\\\ \\small","\\texttt{DP[i, j-1] + score(-, T[j])}","\\end","{cases}","\\texttt","{= max}","\\begin","{cases}","\\small","\\texttt{DP[i-1, j-1] + (match_score}\\texttt{ if }\\texttt{ S[i] == T[j] }\\texttt{ else  }\\texttt{ mismatch_score)}","\\\\ \\small","\\texttt{DP[i-1, j] + gap_score}","\\\\ \\small","\\texttt{DP[i, j-1] + gap_score}","\\end","{cases}","$$ to compute the optimal score, then backtracking (shown below in red) to find the corresponding alignment."),n.a.createElement("table",{id:"param_result"},n.a.createElement("tr",null,n.a.createElement("td",null,n.a.createElement("tr",null,n.a.createElement("td",null,n.a.createElement("label",{className:"param_label"}," Sequence S")),n.a.createElement("td",{colSpan:"4"},n.a.createElement("input",{type:"text",id:"seq1",className:"seq",value:this.state.seq1,maxLength:"20",onChange:this.handleChange}))),n.a.createElement("tr",null,n.a.createElement("td",null,n.a.createElement("label",{className:"param_label"},"Sequence T")),n.a.createElement("td",{colSpan:"4"},n.a.createElement("input",{type:"text",id:"seq2",className:"seq",value:this.state.seq2,maxLength:"20",onChange:this.handleChange}))),n.a.createElement("tr",null,n.a.createElement("td",null,n.a.createElement("table",null,n.a.createElement("tr",null,n.a.createElement("label",{className:"param_label"},"Match Score")),n.a.createElement("tr",null,n.a.createElement("input",{className:"params",id:"match",type:"number",value:this.state.matchScore,onChange:this.handleChange})))),n.a.createElement("td",null,n.a.createElement("table",null,n.a.createElement("tr",null,n.a.createElement("label",{className:"param_label"},"Mismatch Score")),n.a.createElement("tr",null,n.a.createElement("input",{className:"params",id:"mismatch",type:"number",value:this.state.mismatchScore,onChange:this.handleChange})))),n.a.createElement("td",null,n.a.createElement("table",null,n.a.createElement("tr",null,n.a.createElement("label",{className:"param_label"},"Gap Score")),n.a.createElement("tr",null,n.a.createElement("input",{className:"params",id:"gap",type:"number",value:this.state.gapScore,onChange:this.handleChange})))))),n.a.createElement("td",{rowSpan:"10",id:"result"},n.a.createElement("table",{id:"alignment"},n.a.createElement("tr",null,n.a.createElement("table",null,n.a.createElement("tbody",null,n.a.createElement("tr",null,l[this.state.seq1.length][this.state.seq2.length].a.split("").map((e,t)=>n.a.createElement("td",null,e))),n.a.createElement("tr",null,l[this.state.seq1.length][this.state.seq2.length].b.split("").map((e,t)=>n.a.createElement("td",null,e)))))),n.a.createElement("tr",null,"Score: "+l[this.state.seq1.length][this.state.seq2.length].score))))),n.a.createElement("div",null,n.a.createElement(h,{D:l,seq1:this.state.seq1,seq2:this.state.seq2})))}}var u=o;s.a.render(n.a.createElement(n.a.StrictMode,null,n.a.createElement(u,null)),document.getElementById("root"))},4:function(e,t,a){e.exports=a(10)},9:function(e,t,a){}},[[4,1,2]]]);
//# sourceMappingURL=main.50d4eaff.chunk.js.map